{% load static %}
<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{% block title %}Gamerland — Landing{% endblock %}</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- CSS propio -->
  <link rel="stylesheet" href="{% static 'css/style.css' %}">

  <style>
    .text-gradient{
      background: linear-gradient(90deg,#6ea8ff 0%, #bb6bd9 55%, #ff86c8 100%);
      -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent;
    }
    .ratio-21-9{ position:relative; }
    .ratio-21-9::before{ content:""; display:block; padding-top:42%; }
    .ratio-21-9 > .fill{ position:absolute; inset:0; }
  </style>

  {% block extra_head %}{% endblock %}
</head>
<body class="min-h-screen bg-[#0f1722] text-[#e8eef6] motion-safe:scroll-smooth">
  <!-- Canvas de fondo -->
  <canvas id="bg-peripherals" aria-hidden="true"></canvas>

  <!-- Capa de contenido por encima del canvas -->
  <div class="relative z-10">
    {% block content %}{% endblock %}
  </div>

  {% block extra_js %}{% endblock %}

  <!-- Fondo: periféricos neon cayendo -->
  <script>
  (function(){
    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const canvas = document.getElementById('bg-peripherals');
    if(!canvas || prefersReduced) return;

    const ctx = canvas.getContext('2d');
    const DPR_MAX = 2;
    let dpr = Math.min(window.devicePixelRatio || 1, DPR_MAX);

    function fit(){
      const w = window.innerWidth, h = window.innerHeight;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.position = 'fixed';
      canvas.style.inset = '0';
      canvas.style.width = w+'px';
      canvas.style.height = h+'px';
      canvas.style.pointerEvents = 'none';
      canvas.style.zIndex = '0';
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.clearRect(0,0,w,h);
    }
    fit(); window.addEventListener('resize', fit, {passive:true});

    const COLORS = [
      'rgba(110,168,255,0.32)',
      'rgba(187,107,217,0.30)',
      'rgba(255,134,200,0.28)',
      'rgba(59,130,246,0.28)',
      'rgba(168,85,247,0.28)',
      'rgba(52,211,153,0.26)'
    ];

    function shapeGamepad(){
      const p = new Path2D();
      p.moveTo(-24,0); p.bezierCurveTo(-18,-10,18,-10,24,0);
      p.bezierCurveTo(18,10,-18,10,-24,0);
      p.moveTo(8,-2); p.arc(8,-2,1.2,0,Math.PI*2);
      p.moveTo(12,1); p.arc(12,1,1.2,0,Math.PI*2);
      p.moveTo(8,4); p.arc(8,4,1.2,0,Math.PI*2);
      p.moveTo(4,1); p.arc(4,1,1.2,0,Math.PI*2);
      p.rect(-10,-1.5,6,3);
      p.rect(-8.5,-3,3,6);
      p.moveTo(-2,0); p.arc(-2,0,2,0,Math.PI*2);
      p.moveTo(2,0);  p.arc(2,0,2,0,Math.PI*2);
      return p;
    }
    function shapeKeyboard(){
      const p = new Path2D();
      p.rect(-24,-8,48,16);
      for(let y=-5; y<=3; y+=4){
        for(let x=-20; x<=20; x+=6){
          p.rect(x,y,4,2.5);
        }
      }
      return p;
    }
    function shapeMouse(){
      const p = new Path2D();
      p.moveTo(0,-14); p.bezierCurveTo(9,-14,14,-7,14,0);
      p.bezierCurveTo(14,10,8,14,0,14);
      p.bezierCurveTo(-8,14,-14,10,-14,0);
      p.bezierCurveTo(-14,-7,-9,-14,0,-14);
      p.rect(-1, -6, 2, 6);
      return p;
    }
    function shapeHeadset(){
      const p = new Path2D();
      p.moveTo(-18,2); p.bezierCurveTo(-18,-12,18,-12,18,2);
      p.rect(-22,2,6,12);
      p.rect(16,2,6,12);
      p.moveTo(-16,10); p.bezierCurveTo(-10,16,-2,16,2,14);
      return p;
    }

    const SHAPES = [shapeGamepad(), shapeKeyboard(), shapeMouse(), shapeHeadset()];

    const W = () => window.innerWidth;
    const H = () => window.innerHeight;
    const DENSITY = 70000;
    const COUNT = Math.max(18, Math.floor((W()*H())/DENSITY));
    const items = [];

    function spawn(n=COUNT){
      for(let i=0;i<n;i++){
        const scale = 0.8 + Math.random()*1.2;
        const vy = 0.35 + Math.random()*0.9;
        const vx = (Math.random()*0.5 - 0.25);
        const rot = Math.random()*Math.PI*2;
        const vr = (Math.random()*0.01 - 0.005);
        const color = COLORS[(Math.random()*COLORS.length)|0];
        const shape = SHAPES[(Math.random()*SHAPES.length)|0];
        items.push({ x: Math.random()*W(), y: Math.random()*-H(), scale, vy, vx, rot, vr, color, shape, glow: color });
      }
    }
    spawn();

    function drawItem(it){
      ctx.save();
      ctx.translate(it.x, it.y);
      ctx.rotate(it.rot);
      ctx.scale(it.scale, it.scale);

      ctx.lineWidth = 1.4;
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.shadowBlur = 16;
      ctx.shadowColor = it.glow;
      ctx.stroke(it.shape);

      ctx.shadowBlur = 24;
      ctx.strokeStyle = it.color;
      ctx.stroke(it.shape);

      ctx.restore();
    }

    let raf = null, last=0;
    function loop(t){
      if(!last) last = t;
      const dt = Math.min((t - last)/16.666, 2.5);
      last = t;

      const w = W(), h = H();
      ctx.clearRect(0,0,w,h);

      for(const it of items){
        it.x += it.vx * dt;
        it.y += it.vy * dt;
        it.rot += it.vr * dt;
        drawItem(it);
        if(it.y > h + 30){ it.y = -30 - Math.random()*h*0.3; it.x = Math.random()*w; }
        if(it.x < -40) it.x = w+40;
        if(it.x > w+40) it.x = -40;
      }
      raf = requestAnimationFrame(loop);
    }
    raf = requestAnimationFrame(loop);

    document.addEventListener('visibilitychange', ()=>{
      if(document.hidden && raf){ cancelAnimationFrame(raf); raf=null; }
      else if(!raf){ last=0; raf=requestAnimationFrame(loop); }
    });
  })();
  </script>
</body>
</html>
